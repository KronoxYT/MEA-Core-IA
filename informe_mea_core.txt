
# Informe Técnico Exhaustivo: MEA-Core-IA

## 1. Mapa de Arquitectura

### Descripción General

El proyecto `MEA-Core-IA` está estructurado como un sistema de inteligencia artificial modular y monolítico, con una clara separación de responsabilidades en diferentes directorios. Sin embargo, el análisis revela una considerable superposición y duplicación de código, especialmente en el directorio `Otras IA`, que parece contener varias versiones o prototipos del mismo sistema.

La arquitectura principal se puede dividir en las siguientes capas:

1.  **Capa de Interfaz (Bots y Servidor):** Responsable de la interacción con el usuario.
    *   `bots/`: Contiene los bots para diferentes plataformas (CLI, Discord, Telegram).
    *   `server/`: Contiene un servidor web (FastAPI) para exponer la funcionalidad de la IA a través de una API.
2.  **Capa de Núcleo (Core):** El corazón de la IA, donde reside la lógica principal.
    *   `core/`: Contiene los módulos de `Brain`, `Memory`, `Ethics`, `Knowledge`, `Swarm`, etc.
3.  **Capa de Datos (Data):** Almacenamiento persistente de la IA.
    *   `data/`: Contiene las bases de datos (`.db`), archivos de configuración (`.json`) y otros datos.
4.  **Capa de Herramientas y Pruebas (Tools y Tests):**
    *   `tools/`: Scripts para tareas de mantenimiento como backups e importación de datos.
    *   `tests/`: Pruebas unitarias para los módulos del `core`.

### Flujo de Datos (Ejemplo con `CliBot`)

1.  **Entrada del Usuario:** El usuario introduce un comando o una pregunta en la `CliBot` (`bots/cli_bot.py`).
2.  **Procesamiento de Comandos:** La `CliBot` primero comprueba si la entrada es un comando especial (ej. `!settings`, `!dump`).
3.  **Evaluación Ética:** Si no es un comando, la entrada pasa por el `EthicsCore` (`core/ethics.py`) para verificar que la acción es permitida.
4.  **Cerebro (Brain):** La entrada llega al `Brain` (`core/brain.py`), que decide cómo responder.
    *   Consulta la `KnowledgeBase` (`core/knowledge.py`) para buscar principios o hechos relevantes.
    *   Utiliza un modelo de clasificación simple (si está activado) para determinar la intención.
    *   Selecciona una respuesta de `config/responses.json`.
5.  **Memoria:** La conversación (entrada y respuesta) se registra en la `MemoryStore` (`core/memory.py`), que utiliza una base de datos SQLite (`data/mea_memory.db`).
6.  **Respuesta al Usuario:** La respuesta generada se muestra al usuario en la consola.
7.  **Ciclos de Fondo:**
    *   El `SwarmController` (`core/swarm.py`) se ejecuta periódicamente para buscar dispositivos y replicarse.
    *   El `RemoteLogger` (`core/remote_logger.py`) envía la conversación a un servidor central si está activado.

### Diagrama de Arquitectura (Simplificado)

```
+----------------+      +----------------+      +----------------+
|   Interfaces   |----->|  Núcleo (Core) |----->|      Datos     |
| (Bots, Server) |      | (Brain, Ethics)|      | (DBs, JSON)    |
+----------------+      +----------------+      +----------------+
       ^                      |                      ^
       |                      |                      |
       |                      v                      |
       +----------------------|----------------------+
                              |
                       Usuario/Cliente
```

## 2. Evaluación del Estado Actual

### Funcionalidades Implementadas y Operativas

*   **Núcleo de Memoria Persistente (`core/memory.py`):** El sistema utiliza `sqlite3` para almacenar conversaciones y pares clave-valor, lo cual es robusto y funcional. La nueva tabla `replications` es un buen añadido para el `SwarmController`.
*   **Sistema de Ética Basado en Reglas (`core/ethics.py`):** La clase `EthicsCore` implementa una lógica simple pero efectiva para bloquear acciones basadas en palabras clave prohibidas.
*   **Carga de Personalidad y Respuestas (`core/personality.py`, `config/responses.json`):** El sistema carga configuraciones de personalidad y respuestas predefinidas desde archivos JSON, permitiendo una fácil personalización.
*   **Bot de CLI Funcional (`bots/cli_bot.py`):** El bot de línea de comandos es la interfaz más completa. Integra la mayoría de los módulos del `core` y gestiona la interacción con el usuario, incluyendo un menú de configuración.
*   **Base de Conocimiento (`core/knowledge.py`):** Utiliza `sqlite3` para almacenar principios extraídos de manifiestos, lo cual es una base sólida para una IA basada en conocimiento.
*   **Sistema de Pruebas (`tests/`):** Existen pruebas unitarias para varios de los módulos clave, lo cual es una excelente práctica para asegurar la estabilidad.

### Funcionalidades Incompletas o Sin Uso

*   **Bots de Discord y Telegram (`bots/discord_bot.py`, `bots/telegram_bot.py`):** Son esqueletos básicos. No están integrados con el `core` de la IA y su funcionalidad es mínima.
*   **Cerebro de Machine Learning (`core/brain.py`):** Aunque existe la clase `Brain` con un modo "ml", la implementación es un placeholder. Utiliza `scikit-learn` para entrenar un modelo, pero no parece estar integrado de una manera que permita un aprendizaje real o una generación de respuestas avanzada.
*   **Servidor API (`server/main.py`):** Es un servidor FastAPI básico que parece estar diseñado para el aprendizaje remoto, pero no expone la funcionalidad completa de la IA.
*   **Módulos de Curiosidad y Evolución (`core/curiosity.py`, `core/evolution.py`):** Son clases vacías o con lógica simulada. No tienen una implementación funcional.
*   **Módulos de Hardware y Parser (`core/hardware.py`, `core/parser.py`):** Son clases placeholder sin una funcionalidad real.

### Código Duplicado y Redundante

*   **¡El directorio `Otras IA` es un problema mayor!** Contiene múltiples copias y versiones del proyecto (`AetherCore`, `AetherCoreAI`, `AIBotCore`, `MEA-Core-AI-System_v2.0.0_20250809_211629`). Esto crea una enorme confusión y dificulta el mantenimiento. Es crítico decidir cuál es la versión "canónica" y eliminar las demás.
*   **Múltiples archivos `main.py`:** Existen varios `main.py` en diferentes subdirectorios, cada uno con una lógica de arranque ligeramente diferente. Esto debería unificarse.
*   **Redundancia en `core/ethics.py`:** La clase `Ethics_Core` está duplicada dentro del mismo archivo.

### Riesgos de Seguridad, Rendimiento o Estabilidad

*   **Seguridad de los Bots:** Los tokens para los bots de Discord y Telegram se leen desde variables de entorno, lo cual es bueno. Sin embargo, el código no tiene manejo de errores robusto para el caso en que los tokens no estén disponibles.
*   **Rendimiento de la Memoria:** La `MemoryStore` carga todo el historial de conversaciones en memoria para algunas operaciones, lo cual podría ser un problema a medida que la base de datos crece.
*   **Estabilidad del `SwarmController`:** La lógica para detectar dispositivos externos es muy simple y podría no ser robusta en todos los sistemas operativos. La copia de archivos podría fallar si los permisos no son correctos.
*   **Falta de Validación de Entrada:** No hay una validación exhaustiva de la entrada del usuario, lo que podría llevar a errores inesperados si se introducen datos malformados.

## 3. Historial y Cambios Clave

### Evolución del Proyecto

1.  **Fase Inicial (Prototipos Aislados):**
    *   El proyecto parece haber comenzado como una colección de ideas y prototipos en el directorio `Otras IA`.
    *   `AetherCore`, `AIBotCore`, etc., representan diferentes enfoques iniciales. Por ejemplo, `AetherCore` ya incluía un motor de búsqueda `bm25.py` y un `chunker.py`, sentando las bases para el sistema de conocimiento.
    *   Estos prototipos estaban en gran medida aislados y no formaban un sistema cohesivo.

2.  **Fase de Consolidación (El `core` principal):**
    *   El código se consolidó en el directorio raíz del proyecto, con una estructura más clara (`core`, `bots`, `data`).
    *   Se crearon los módulos fundamentales como `core/memory.py`, `core/ethics.py`, y `core/knowledge.py`, cada uno con una responsabilidad bien definida.
    *   El `bots/cli_bot.py` se convirtió en la interfaz principal para probar e interactuar con el `core`.

3.  **Fase de Expansión y Refactorización (Estado Actual):**
    *   **Refactorización a Clases:** Módulos como `bots/cli_bot.py` y `core/swarm.py` fueron refactorizados de scripts a clases (`CliBot`, `SwarmController`), lo cual mejora la organización y reutilización del código.
    *   **Persistencia Mejorada:** Se pasó de archivos JSON (`data/config.json`) a bases de datos SQLite (`data/mea_memory.db`, `data/knowledge_base.db`), lo que permite un almacenamiento más robusto y escalable.
    *   **Nuevas Funcionalidades:** Se introdujeron conceptos como el `SettingsManager` para una configuración centralizada, el `RemoteLogger` para aprendizaje distribuido y el `SwarmController` para replicación.
    *   **Ampliación de Dependencias:** El archivo `requirements.txt` muestra la adición de librerías clave como `discord.py`, `python-telegram-bot`, `fastapi` y `scikit-learn`, indicando la intención de expandir la funcionalidad a nuevas plataformas y añadir capacidades de machine learning.

### Cambios Clave Identificados

*   **De JSON a SQLite:** El cambio más significativo es el paso de archivos de configuración y memoria basados en JSON a una base de datos SQLite. Esto es una mejora fundamental para la estabilidad y escalabilidad del proyecto.
*   **Introducción de `SettingsManager`:** Centralizar la configuración en `core/settings_manager.py` es un paso importante para evitar la duplicación de código y facilitar la gestión de los ajustes del sistema.
*   **Refactorización del `CliBot`:** La conversión del `cli_bot` a una clase ha permitido una mejor integración con los demás módulos del `core`, como se puede ver en su método `__init__`.
*   **Creación de Esqueletos de Bots:** La adición de `discord_bot.py` y `telegram_bot.py`, aunque incompletos, indica una clara intención de hacer que la IA sea accesible desde múltiples plataformas.

## 4. Oportunidades de Mejora (sin LLMs externos)

### Algoritmos y Estructuras de Datos Recomendados

*   **Para Razonamiento y Búsqueda (`core/brain.py`, `core/knowledge.py`):**
    *   **Implementar BM25F:** La implementación actual de `BM25` en `Otras IA/AetherCore/core/bm25.py` es un buen comienzo. Debería moverse al `core` principal y mejorarse a **BM25F**, que permite ponderar diferentes campos (por ejemplo, título, contenido, metadatos). Esto mejoraría significativamente la relevancia de la búsqueda.
    *   **Entrenar un Modelo Word2Vec/GloVe:** En lugar de depender de modelos externos, puedes entrenar tu propio modelo de incrustación de palabras (`Word2Vec` o `GloVe`) en el texto de tu `knowledge_base.db`. Esto permitiría la búsqueda semántica (encontrar documentos con un significado similar, no solo por palabras clave). La biblioteca `gensim` es perfecta para esto.
    *   **Implementar un Motor de Reglas:** Para la toma de decisiones más complejas, se podría implementar un motor de reglas simple de encadenamiento hacia adelante. Esto te permitiría definir reglas como "SI el usuario pregunta sobre 'X' Y el contexto es 'Y', ENTONCES responde con 'Z'". La biblioteca `pyke` o una implementación personalizada funcionarían bien aquí.

*   **Para la Memoria (`core/memory.py`):**
    *   **Implementar Consolidación de Memoria:** El `MemoryStore` debería tener un mecanismo para "consolidar" los recuerdos a lo largo del tiempo. Esto podría implicar resumir conversaciones, identificar entidades y relaciones clave, y almacenarlas de una manera más estructurada (por ejemplo, una base de datos de grafos como `Neo4j` o añadiendo tablas a la base de datos SQLite existente).
    *   **Añadir una Capa de Caché:** Para los recuerdos a los que se accede con frecuencia, una caché en memoria (como un diccionario de Python con una política LRU) aceleraría significativamente los tiempos de respuesta.

### Optimizaciones de Rendimiento y Modularidad

*   **Refactorizar `Otras IA`:** Esta es la máxima prioridad. El código en `Otras IA` debe ser analizado, y cualquier componente útil (como el `BM25Index`) debe ser integrado en el `core` principal. El resto debe ser eliminado para evitar confusiones.
*   **Operaciones Asíncronas:** Para tareas como peticiones de red (`RemoteLogger`) o E/S de archivos, utiliza la biblioteca `asyncio` de Python para evitar bloquear el hilo principal. Esto es especialmente importante para los bots y el servidor FastAPI.
*   **Gestión de la Configuración:** El `SettingsManager` es un buen comienzo, pero debe ser utilizado de manera consistente en todos los módulos. Todas las rutas y configuraciones hardcodeadas deben ser movidas a `config/settings.json`.
*   **Inyección de Dependencias:** En lugar de instanciar módulos directamente dentro de otros módulos (por ejemplo, `CliBot` creando su propio `Brain`), considera usar un patrón de inyección de dependencias. Esto haría el código más modular y fácil de probar.

### Ideas para Bots Más Funcionales y una API Más Completa

*   **Bots (`bots/`):**
    *   **Integración Completa con el `core`:** Los bots de Discord y Telegram deben ser refactorizados para usar los mismos módulos del `core` que el `CliBot`. Deben tener acceso al `Brain`, `MemoryStore`, etc.
    *   **Componentes Interactivos:** Utiliza características específicas de la plataforma como los botones y menús de selección de Discord o los teclados en línea de Telegram para crear una experiencia más interactiva.
*   **API (`server/main.py`):**
    *   **Exponer la Funcionalidad del `core`:** El servidor FastAPI debe exponer endpoints para todas las funcionalidades del `core`:
        *   `POST /query`: Para enviar una consulta al `Brain`.
        *   `GET /memory/{key}`: Para recuperar un valor del `MemoryStore`.
        *   `GET /status`: Para obtener el estado de todos los módulos.
    *   **Soporte de WebSocket:** Para la comunicación en tiempo real (por ejemplo, para una interfaz de chat basada en la web), se debe añadir un endpoint de WebSocket.

## 5. Plan de Acción Priorizado

### Tareas Críticas (Corto Plazo)

1.  **Limpieza y Consolidación del Código:**
    *   **Acción:** Eliminar el directorio `Otras IA`.
    *   **Justificación:** Es la fuente más grande de confusión y código duplicado. Antes de añadir nuevas funcionalidades, es crucial tener una única base de código limpia y clara.
    *   **Archivos Afectados:** Todo el directorio `Otras IA/`.

2.  **Refactorización de Módulos Duplicados:**
    *   **Acción:** Unificar las diferentes versiones de los módulos del `core` (ej. `ethics.py`) y eliminar las clases duplicadas.
    *   **Justificación:** Asegura que haya una única fuente de verdad para cada pieza de funcionalidad.
    *   **Archivos Afectados:** `core/ethics.py`, y cualquier otro módulo con clases duplicadas.

3.  **Centralización de la Configuración:**
    *   **Acción:** Modificar todos los módulos para que utilicen el `SettingsManager` (`core/settings_manager.py`) en lugar de cargar archivos de configuración directamente.
    *   **Justificación:** Mejora la mantenibilidad y consistencia del sistema.
    *   **Archivos Afectados:** `bots/cli_bot.py`, `core/brain.py`, etc.

### Mejoras Estructurales (Medio Plazo)

1.  **Implementación Completa de los Bots:**
    *   **Acción:** Refactorizar `bots/discord_bot.py` y `bots/telegram_bot.py` para que utilicen la misma lógica y módulos del `core` que el `CliBot`.
    *   **Justificación:** Expande el alcance de la IA a nuevas plataformas y asegura una experiencia de usuario consistente.
    *   **Archivos Afectados:** `bots/discord_bot.py`, `bots/telegram_bot.py`.

2.  **Desarrollo de la API del Servidor:**
    *   **Acción:** Implementar los endpoints REST en `server/main.py` para exponer las funcionalidades clave del `core` (query, memoria, estado).
    *   **Justificación:** Permite la integración con interfaces de usuario web y otras aplicaciones externas.
    *   **Archivos Afectados:** `server/main.py`.

3.  **Mejora del Motor de Búsqueda:**
    *   **Acción:** Reemplazar la búsqueda simple por palabras clave en `core/brain.py` con el motor `BM25` que se encuentra en `Otras IA/AetherCore/core/bm25.py`.
    *   **Justificación:** Mejora drásticamente la calidad de la búsqueda en la base de conocimientos.
    *   **Archivos Afectados:** `core/brain.py`, `core/knowledge.py`.

### Innovaciones Opcionales (Largo Plazo)

1.  **Implementación de `Word2Vec`:**
    *   **Acción:** Entrenar un modelo `Word2Vec` con el contenido de la `KnowledgeBase` para permitir la búsqueda semántica.
    *   **Justificación:** Permite a la IA entender el significado y el contexto, no solo las palabras clave.

2.  **Desarrollo del Módulo de Evolución:**
    *   **Acción:** Implementar la lógica en `core/evolution.py` para que la IA pueda experimentar con diferentes configuraciones de personalidad y ética, y aprender cuáles funcionan mejor.
    *   **Justificación:** Introduce una capacidad de auto-mejora a largo plazo.

3.  **Interfaz Web Completa:**
    *   **Acción:** Crear una interfaz de usuario web utilizando React o similar que consuma la API de FastAPI.
    *   **Justificación:** Proporciona una experiencia de usuario rica e interactiva.

## 6. Checklist de Pruebas

### Módulos que Requieren Unit Tests

*   `core/brain.py`: Probar las diferentes lógicas de selección de respuestas.
*   `core/swarm.py`: Probar la lógica de detección de dispositivos y replicación en diferentes sistemas operativos (usando mocks).
*   `server/main.py`: Probar los endpoints de la API.
*   `bots/discord_bot.py` y `bots/telegram_bot.py`: Probar los comandos y la interacción con el `core`.

### Casos de Prueba Sugeridos

*   **`test_brain.py`:**
    *   `test_get_response_from_kb()`: Verificar que el cerebro puede obtener una respuesta de la base de conocimientos.
    *   `test_get_response_with_ml_model()`: Verificar que el cerebro puede usar el modelo de ML para seleccionar una respuesta.
    *   `test_get_response_fallback()`: Verificar que el cerebro devuelve una respuesta general cuando no encuentra una específica.
*   **`test_swarm.py`:**
    *   `test_replication_to_windows_drive()`: Probar la replicación en un entorno simulado de Windows.
    *   `test_replication_to_linux_drive()`: Probar la replicación en un entorno simulado de Linux.
    *   `test_replication_failure_on_permission_error()`: Probar que la replicación falla si no hay permisos de escritura.
*   **`test_server.py`:**
    *   `test_learn_endpoint()`: Probar que el endpoint `/api/learn` guarda correctamente una conversación.
    *   `test_query_endpoint()`: Probar que el endpoint `/query` devuelve una respuesta del `Brain`.

## 7. Propuestas de Nuevas Funcionalidades

*   **Herramienta de Administración Web:** Una interfaz web simple para administrar la IA, que permita:
    *   Ver y editar la `KnowledgeBase`.
    *   Ver y editar la `MemoryStore`.
    *   Ajustar la configuración de la personalidad y la ética.
    *   Ver los logs del sistema.
*   **Sistema de Plugins Mejorado:** Un sistema de plugins más robusto que permita a los usuarios añadir nuevas funcionalidades a la IA sin modificar el código del `core`.
*   **Integración con Calendario y Correo Electrónico:** Permitir que la IA acceda al calendario y al correo electrónico del usuario para proporcionar recordatorios y resúmenes.
*   **Capacidades de Resumen de Texto:** Implementar un algoritmo de resumen de texto (como TextRank) para que la IA pueda resumir artículos o documentos.
*   **Interfaz de Voz:** Integrar librerías de reconocimiento de voz y síntesis de voz para permitir la interacción por voz con la IA.

